### 프록시 매커니즘을 이해하자
_JPA 표준 명세는 지연 로딩의 구현 방법을 JPA 구현체에 위임. 여기서 설명하는 내용은 하이버네티으 구현체에 대한 내용이다_


* 프록시 객체
    + 지연 로딩 기능 사용 시 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체 

**em.getReference()**

* 데이터 베이스 조회를 미루는 가짜 (프록시) 엔티티 객체 조회
* 내부 라이브러리를 사용
* 껍데기는 같으나 안이 비어있는 형태
    
**특징** 

    * 실제 클래스를 상속받아서 만들어짐. (내부에서 하이버네이트가 해줌)
    * 사용하는 입장에서 진짜인지 구분하지않고 사용해도 됨
    * 실제 객체의 참조(target)를 보관
    * 영속성 컨텍스트를 통해서 초기화 요청을 하는데, 초기화하면 DB에서 값을 가져와서 참조에 매핑
    * 프록시 객체는 처음 사용할 때 한번만 초기화
    * 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님. 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
    * 프록시 객체는 원본 엔티티를 상속받음. 따라서 타입 체크시 주의해야함 (== 비교실패, 대신 instance of 사용)
    * 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
    * 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제발생 (하이버네이트는 org.hibernate.LazyInitializationException 예외를 터뜨림)

**프록시 확인**
```
    * 프록시 인스턴스의 초기화 여부 확인
        + emf.getPersistenceUnitUtil().isLoaded(엔티티)
    * 프록시 클래스 확인 방법
        + entity.getClass().getName() 출력(ex. HibernateProxy..)
    * 프록시 강제 초기화
        + org.hibernate.Hibernate.initialize(엔티티);
    * 참고 : JPA 표준은 강제 초기화 없음
      강제 호출 : member.getName();
```
    